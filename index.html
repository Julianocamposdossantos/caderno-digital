<!DOCTYPE html>
<html lang="pt-br">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Caderno</title>
</head>
<body>
	<style> 
		
		* {
			padding: 0;
			margin: 0;
			box-sizing: border-box;
		}

		.caderno {
			display: flex;
			padding: 1rem;
			flex-direction: column;
		}

		h1 {
			text-align: center;
			padding-block: 1rem;
		}

		form {
			display: flex;
			flex-direction: column;
		}

		.salvar {
			padding: 1rem;
			color: black;
			background: steelblue;
			border-radius: 15%;
		}	

		.delete {
			color: black;
			background: red;
			border-radius: 15%;
		}

		.buttons {
			padding: 1rem;
			gap: .5rem;
			display: flex;
		}

		.between {
			display: flex;
			justify-content: flex-end;
		}

		textarea {
			width: 90%;
			margin: 0 auto;
			line-height: 160%;
			padding: 1rem;
		}

		p {
			position: absolute;
		}

		.none {
			display: none;
		}

		.dark {
			position: absolute;
			right: 0;
			color: white;
			background: black;
			border-radius: 10%;
			margin: 1rem;
			padding: 0.5rem;
		}

		.escuro {
			background: #1b1b1c;
			color: white;
			transition: 1s;
		}

		.chek_theme {
			visibility: hidden;
			position: absolute;
		}

	</style>

	<section class="caderno">

		<button class="dark">
			<input class="chek_theme" type="checkbox" id="input">
			<label for="input">
				<span class="texto"></span>
			</label>
		</button>
		<form action="">
			<h1>Anotações</h1>

			<textarea name="" id="" cols="30" rows="25">
			</textarea>

			<div class="between">
				<div class="buttons">
					<input type="submit" value="Salvar" class="salvar">
					<button class="delete">
						<span>Excluir</span>
					</button>
				</div>
			</div>
		</form>
	</section>

	<script>


		let form  = document.querySelector('form')
		let area = form.querySelector('textarea');
		let apagar = document.querySelector('.delete')
		let salvar = document.querySelector('.salvar')
		let caderno = document.querySelector('.caderno')
		let chek = document.querySelector('.chek_theme')
		let texto = document.querySelector('.texto')

		form.addEventListener('submit' , event => {
			event.preventDefault()

			let area = form.querySelector('textarea').value

			localStorage.area = area
		})

		area.innerHTML = localStorage.area

		salvar.onclick = () => {

			let condicao = document.createElement('p')
			condicao.classList.add('salvado')	
			form.appendChild(condicao);

			if (area.value == '') {
				alert('Não é possível salvar uma anotação vazia!')
			}else {
				salvar.value = 'salvo'
				condicao.innerText = 'Anotação salva com sucesso!'
			}
		}

		apagar.addEventListener('click' , event => {

			if (area.value == '') {
				alert('Não é possível apagar uma anotação que não existe!')
			}else {
				let apagaOuNao = confirm('Tem certeza que deseja Excluir essa anotação? Essa ação não poderá ser desfeita!')

				if(apagaOuNao == true) {
					let salvo = document.querySelector('.salvado')

					if(salvo == null) {
						area.value = '';
					}else {
						salvo.classList.add('none')				
					}

					area.value =''
					salvar.value = 'salvar'
				}
			}
		})

		if(localStorage.area == undefined) {
			area.value =''
		}

		chek.addEventListener('change', () => {
			if(chek.checked == true) {
				caderno.classList.toggle('escuro')
				area.style.backgroundColor = '#181c1f';
				area.style.color = 'white';
				localStorage.dark = 'true';
				texto.textContent = 'Light Theme'
			}else {
				caderno.classList.remove('escuro')
				area.style.backgroundColor = '';
				area.style.color = '';
				localStorage.dark = 'false';
				texto.textContent = 'Dark Theme'
			}
		})

		window.onload = () => {
			if(localStorage.dark == 'true') {
				chek.checked = () => {}
				caderno.classList.add('escuro')
				area.style.backgroundColor = '#181c1f'
				area.style.color = 'white'	
				texto.textContent = 'Light Theme'
			}else {
				caderno.classList.remove('escuro')
				area.style.backgroundColor = '';
				area.style.color = '';
				texto.textContent = 'Dark Theme'
			}			
		}

	</script>
</body>
</html> 



<!-- 

Curso CRUD

  Primeiramente vamos fazer o dowload do projeto em: https://github.com/alura-cursos/2016-JS-na-web-crud-com-JavaScript-assincrono/archive/projeto_inicial.zip

Usaremos o ajax para fazer essa cominicação entre a aplicação e a API para obter os dados.Em admin criamos a pasta service dentro de service criamos o arquivo cliente-service.js. Para fazer essa comunicação usaremos alguns métodos e quem vai fornecer esses métodos pra gente vai ser o objeto XMLHttpRequest usando new XMLHttpRequest() >> const http = new XMLHttpRequest() >> para abrir a comunicação entre a aplicação e a API vamos usar o método open que recebe 2 argumentos o primeiro é oq eu vou pedir pra ele, e o segundo é o endereço de para onde eu quero enviar >> http.open("GET", 'http://localhost:3000/profile') >> depois >> http.send() para enviar os dados depois linkamos com o aqrquivo HTML. Depois que ele fizer a requisição devemos indicar oq ele deve fazer com a resposta do servidor usarerom onload >>

http.onload = () => {
const data = http.response >> resposta do servidor
}

imprimindo a resposta no console nos deparamos com um erro ERR_CONNECTION_REFUSED ele não conseguiu fazer a comunicação, isso prq localhost:3000 não existe. Estamos simulando uma API (mocando dados) e para fazer essas simulaçôes vamos usar o json-server que esta listado nas dependencias do projeto em package.json. No terminal em ADMIN fazemos nmp install para baixar as dependencias.Para ele rodar fazemos o clássico watch e no console vemos o conteúdo do arquivo db.json. 

Próximo passo é exibir ele no corpo da tabela, para isso temos que pegar os dados da API e colocá-los no HTML criando um template que vai receber esses dados, em lista_cliente.html temos o seguinte código >>
 

<td class="td" data-td>${nome}</td>
<td>${email}</td>
<td>
  <ul class="tabela__botoes-controle">
      <li><a href="../telas/edita_cliente.html" class="botao-simples botao-simples--editar">Editar</a></li>
      <li><button class="botao-simples botao-simples--excluir" type="button">Excluir</button></li>
  </ul>
</td> 

o copiamos mas embaixo de thead colocamos >> 

<tbody data-tabela>
<tbody/>
,
Em cliente service colamos o código em cima do que já tinhamos digitado, e para o js reconhecer criamos uma função >>

const criaNovaLinha = () => {
const conteudo = `<td class="td" data-td>${nome}</td>
<td>${email}</td>
<td>
  <ul class="tabela__botoes-controle">
      <li><a href="../telas/edita_cliente.html" class="botao-simples botao-simples--editar">Editar</a></li>
      <li><button class="botao-simples botao-simples--excluir" type="button">Excluir</button></li>
  </ul>
</td> 
`
}

Na const conteudo usamos o template literals para funcionar, ele reconhece se tiver ${} que é um js isso acontece com o nome e email que logo a frente usaremos para pegar os dados da API esses dados colocamos como parâmetro da função >>

const criaNovaLinha = (nome, email) => {}

E como vamos criar uma linha vamos usar >> 

const linhaNovoCliente = document.querySelector('tr')

para colocar o conteúdo dentro da tr usamos o inner.HTML , entao embaixo do aconto grave fazemos>>

linhaNovoCliente.innerHTMl = conteudo
return linhaNovoCliente >> por ser uma função

Usamos o data-tabela para refenciar a tabela criando uma const querySelector,  para colocar a linha dentro da tabela usamos o append >>

tabela.appendChild(criaNovaLinha(nome, email))

dentro do onload criamosum forEach para percorrer o array e de fato encontrar cada um referente a cad uum >>

http.onload = () => {
  const data = http.response 
  data.forEach(elemento => {
   tabela.appendChild(criaNovaLinha(elemento.nome, elemento.email)) >> em cada cliente criamos uma linha especifica
})
}

ao vermos o arquivo ele deu um erro isso prq o http.response esta devolvendo texto e nao reconhece com js válido temos que transformar essa resposta em objeto js para poder percorre-lo, usamos o JSON.parse() >>


http.onload = () => {
  const data = JSON.parse(http.response)
  data.forEach(elemento => {
   tabela.appendChild(criaNovaLinha(elemento.nome, elemento.email))
})
}


Fazendo isso ele exibirá a tr na tela com os dados do cliente, criando uma situação hipotética ele repete o código se referindo a semana passada cria outra conexao outro open outro send outro localhost e gera um código enorme, temos outra forma de tratar esses dados sem tanta confusão;

-------------------PROMISSES----------------

Fizemos a parte inicial que era criar a comunicação e listar os clientes na tela um grande problema seria em relação a dados da semana passada no qual estaria muito dificil de manipular esse código.

callback - é a função auxiliar que é disparada imediatamente logo após uma requisição assincrona.







  
 












 -->